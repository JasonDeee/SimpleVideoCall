<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Call P2P - Real WebRTC</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
      }

      .container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: 1200px;
        width: 90%;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .header p {
        font-size: 1.1em;
        opacity: 0.9;
      }

      .video-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
      }

      .video-wrapper {
        position: relative;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        overflow: hidden;
        aspect-ratio: 16/9;
      }

      .video-wrapper video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .video-label {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 0.9em;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        flex-wrap: wrap;
      }

      .btn {
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 12px 24px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 1em;
        font-weight: 600;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn.primary {
        background: #4caf50;
        border-color: #4caf50;
      }

      .btn.primary:hover {
        background: #45a049;
      }

      .btn.danger {
        background: #f44336;
        border-color: #f44336;
      }

      .btn.danger:hover {
        background: #da190b;
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .status {
        text-align: center;
        margin: 20px 0;
        padding: 15px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        font-weight: 500;
      }

      .connection-info {
        background: rgba(0, 0, 0, 0.2);
        padding: 15px;
        border-radius: 10px;
        margin-top: 20px;
        font-family: monospace;
        font-size: 0.9em;
      }

      .connection-info h3 {
        margin-bottom: 10px;
        color: #4caf50;
      }

      .instructions {
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
      }

      .instructions h3 {
        margin-bottom: 15px;
        color: #ffd700;
      }

      .instructions ol {
        padding-left: 20px;
      }

      .instructions li {
        margin-bottom: 8px;
        line-height: 1.5;
      }

      .config-section {
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
      }

      .config-section h3 {
        margin-bottom: 15px;
        color: #ffd700;
      }

      .config-input {
        width: 100%;
        padding: 10px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        margin-bottom: 10px;
      }

      .config-input::placeholder {
        color: rgba(255, 255, 255, 0.7);
      }

      @media (max-width: 768px) {
        .video-container {
          grid-template-columns: 1fr;
        }

        .container {
          padding: 20px;
          margin: 10px;
        }

        .header h1 {
          font-size: 2em;
        }

        .controls {
          flex-direction: column;
          align-items: center;
        }

        .btn {
          width: 100%;
          max-width: 300px;
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üìπ Video Call P2P - Real WebRTC</h1>
        <p>K·∫øt n·ªëi th·∫≠t v·ªõi Cloudflare Workers Signaling</p>
      </div>

      <div class="config-section">
        <h3>‚öôÔ∏è C·∫•u h√¨nh Signaling Server</h3>
        <input
          type="text"
          id="signalingUrl"
          class="config-input"
          placeholder="https://simple-vid-call.caocv-work.workers.dev/"
          value="https://simple-vid-call.caocv-work.workers.dev/"
        />
        <button class="btn" id="testConnectionBtn">üîó Test Connection</button>
        <div id="connectionStatus"></div>
      </div>

      <div class="video-container">
        <div class="video-wrapper">
          <video id="localVideo" autoplay muted playsinline></video>
          <div class="video-label">Video c·ªßa b·∫°n</div>
        </div>
        <div class="video-wrapper">
          <video id="remoteVideo" autoplay playsinline></video>
          <div class="video-label">Video ng∆∞·ªùi g·ªçi</div>
        </div>
      </div>

      <div class="status" id="status">S·∫µn s√†ng ƒë·ªÉ b·∫Øt ƒë·∫ßu cu·ªôc g·ªçi</div>

      <div class="controls">
        <button class="btn primary" id="startBtn">üé• B·∫Øt ƒë·∫ßu</button>
        <button class="btn" id="callBtn" disabled>üìû G·ªçi</button>
        <button class="btn danger" id="hangupBtn" disabled>üì¥ K·∫øt th√∫c</button>
        <button class="btn" id="muteBtn" disabled>üîá T·∫Øt ti·∫øng</button>
        <button class="btn" id="videoBtn" disabled>üìπ T·∫Øt video</button>
      </div>

      <div class="connection-info" id="connectionInfo" style="display: none">
        <h3>üîó Th√¥ng tin k·∫øt n·ªëi:</h3>
        <div id="connectionDetails"></div>
      </div>

      <div class="instructions">
        <h3>üìã H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:</h3>
        <ol>
          <li>
            <strong>C·∫•u h√¨nh:</strong> Nh·∫≠p URL c·ªßa Cloudflare Worker signaling
            server
          </li>
          <li>
            <strong>Test:</strong> Nh·∫•n "Test Connection" ƒë·ªÉ ki·ªÉm tra k·∫øt n·ªëi
          </li>
          <li><strong>Ng∆∞·ªùi 1:</strong> Nh·∫•n "B·∫Øt ƒë·∫ßu" ‚Üí "G·ªçi" ƒë·ªÉ t·∫°o room</li>
          <li><strong>Ng∆∞·ªùi 1:</strong> Chia s·∫ª Room ID cho ng∆∞·ªùi 2</li>
          <li>
            <strong>Ng∆∞·ªùi 2:</strong> Nh·∫•n "B·∫Øt ƒë·∫ßu" ‚Üí "G·ªçi" v√† nh·∫≠p Room ID
          </li>
          <li>
            <strong>K·∫øt n·ªëi:</strong> Cu·ªôc g·ªçi P2P th·∫≠t s·∫Ω ƒë∆∞·ª£c thi·∫øt l·∫≠p!
          </li>
        </ol>
      </div>
    </div>

    <script>
      class RealVideoCallApp {
        constructor() {
          this.localStream = null;
          this.remoteStream = null;
          this.peerConnection = null;
          this.signaling = null;
          this.isInitiator = false;
          this.isConnected = false;
          this.roomId = null;
          this.peerId = null;

          // WebRTC configuration
          this.configuration = {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
            ],
          };

          this.initializeElements();
          this.setupEventListeners();
        }

        initializeElements() {
          this.localVideo = document.getElementById("localVideo");
          this.remoteVideo = document.getElementById("remoteVideo");
          this.status = document.getElementById("status");
          this.connectionInfo = document.getElementById("connectionInfo");
          this.connectionDetails = document.getElementById("connectionDetails");
          this.connectionStatus = document.getElementById("connectionStatus");

          this.startBtn = document.getElementById("startBtn");
          this.callBtn = document.getElementById("callBtn");
          this.hangupBtn = document.getElementById("hangupBtn");
          this.muteBtn = document.getElementById("muteBtn");
          this.videoBtn = document.getElementById("videoBtn");
          this.testConnectionBtn = document.getElementById("testConnectionBtn");
          this.signalingUrl = document.getElementById("signalingUrl");
        }

        setupEventListeners() {
          this.startBtn.addEventListener("click", () => this.startCall());
          this.callBtn.addEventListener("click", () => this.handleCallButton());
          this.hangupBtn.addEventListener("click", () => this.hangup());
          this.muteBtn.addEventListener("click", () => this.toggleMute());
          this.videoBtn.addEventListener("click", () => this.toggleVideo());
          this.testConnectionBtn.addEventListener("click", () =>
            this.testConnection()
          );
        }

        async testConnection() {
          const url = this.signalingUrl.value.trim();
          if (!url) {
            this.updateConnectionStatus(
              "Vui l√≤ng nh·∫≠p URL signaling server",
              "error"
            );
            return;
          }

          try {
            this.updateConnectionStatus("ƒêang test k·∫øt n·ªëi...", "info");

            const response = await fetch(url);
            const data = await response.json();

            if (data.name === "WebRTC Signaling Server") {
              this.updateConnectionStatus("‚úÖ K·∫øt n·ªëi th√†nh c√¥ng!", "success");
              this.signaling = new WebRTCSignaling(url);
            } else {
              this.updateConnectionStatus(
                "‚ùå Kh√¥ng ph·∫£i signaling server",
                "error"
              );
            }
          } catch (error) {
            console.error("Connection test failed:", error);
            this.updateConnectionStatus(
              "‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server",
              "error"
            );
          }
        }

        updateConnectionStatus(message, type) {
          this.connectionStatus.innerHTML = `<div style="padding: 10px; border-radius: 5px; margin-top: 10px; ${
            type === "success"
              ? "background: #d4edda; color: #155724;"
              : type === "error"
              ? "background: #f8d7da; color: #721c24;"
              : "background: #d1ecf1; color: #0c5460;"
          }">${message}</div>`;
        }

        async startCall() {
          if (!this.signaling) {
            this.updateStatus("Vui l√≤ng test k·∫øt n·ªëi signaling server tr∆∞·ªõc");
            return;
          }

          try {
            this.updateStatus("ƒêang kh·ªüi t·∫°o camera v√† microphone...");

            this.localStream = await navigator.mediaDevices.getUserMedia({
              video: true,
              audio: true,
            });

            this.localVideo.srcObject = this.localStream;
            this.updateStatus("Camera v√† microphone ƒë√£ s·∫µn s√†ng");

            this.startBtn.disabled = true;
            this.callBtn.disabled = false;
          } catch (error) {
            console.error("L·ªói khi truy c·∫≠p camera/microphone:", error);
            this.updateStatus(
              "L·ªói: Kh√¥ng th·ªÉ truy c·∫≠p camera/microphone. Vui l√≤ng ki·ªÉm tra quy·ªÅn truy c·∫≠p."
            );
          }
        }

        handleCallButton() {
          if (this.roomId && !this.isInitiator) {
            this.joinCall();
          } else {
            this.initiateCall();
          }
        }

        async initiateCall() {
          if (!this.localStream) {
            this.updateStatus("Vui l√≤ng b·∫Øt ƒë·∫ßu camera tr∆∞·ªõc");
            return;
          }

          try {
            this.updateStatus("ƒêang thi·∫øt l·∫≠p k·∫øt n·ªëi...");

            // Generate room ID
            this.roomId = this.generateRoomId();
            this.peerId = this.generatePeerId();
            this.isInitiator = true;

            // Create peer connection
            this.peerConnection = new RTCPeerConnection(this.configuration);
            this.setupPeerConnection();

            // Add local stream
            this.localStream.getTracks().forEach((track) => {
              this.peerConnection.addTrack(track, this.localStream);
            });

            // Connect to signaling server
            await this.signaling.connect(this.roomId, this.peerId);

            this.updateStatus(
              `ƒê√£ t·∫°o room: ${this.roomId}. Chia s·∫ª Room ID n√†y cho ng∆∞·ªùi 2.`
            );
            this.showConnectionInfo();

            this.callBtn.disabled = true;
            this.hangupBtn.disabled = false;
            this.muteBtn.disabled = false;
            this.videoBtn.disabled = false;
          } catch (error) {
            console.error("L·ªói khi t·∫°o cu·ªôc g·ªçi:", error);
            this.updateStatus("L·ªói khi t·∫°o cu·ªôc g·ªçi");
          }
        }

        async joinCall() {
          if (!this.localStream) {
            this.updateStatus("Vui l√≤ng b·∫Øt ƒë·∫ßu camera tr∆∞·ªõc");
            return;
          }

          // Prompt for room ID
          const roomId = prompt("Nh·∫≠p Room ID t·ª´ ng∆∞·ªùi 1:");
          if (!roomId) {
            this.updateStatus("Vui l√≤ng nh·∫≠p Room ID");
            return;
          }

          try {
            this.updateStatus("ƒêang tham gia cu·ªôc g·ªçi...");

            this.roomId = roomId;
            this.peerId = this.generatePeerId();
            this.isInitiator = false;

            // Create peer connection
            this.peerConnection = new RTCPeerConnection(this.configuration);
            this.setupPeerConnection();

            // Add local stream
            this.localStream.getTracks().forEach((track) => {
              this.peerConnection.addTrack(track, this.localStream);
            });

            // Connect to signaling server
            await this.signaling.connect(this.roomId, this.peerId);

            this.updateStatus(`ƒê√£ tham gia room: ${this.roomId}`);
            this.showConnectionInfo();

            this.callBtn.disabled = true;
            this.hangupBtn.disabled = false;
            this.muteBtn.disabled = false;
            this.videoBtn.disabled = false;
          } catch (error) {
            console.error("L·ªói khi tham gia cu·ªôc g·ªçi:", error);
            this.updateStatus("L·ªói khi tham gia cu·ªôc g·ªçi");
          }
        }

        setupPeerConnection() {
          this.peerConnection.onicecandidate = (event) => {
            if (event.candidate && this.signaling) {
              this.signaling.sendIceCandidate(event.candidate);
            }
          };

          this.peerConnection.ontrack = (event) => {
            this.remoteStream = event.streams[0];
            this.remoteVideo.srcObject = this.remoteStream;
            this.isConnected = true;
            this.updateStatus("ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng!");
          };

          this.peerConnection.onconnectionstatechange = () => {
            console.log(
              "Connection state:",
              this.peerConnection.connectionState
            );
            if (this.peerConnection.connectionState === "connected") {
              this.updateStatus("K·∫øt n·ªëi P2P ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p!");
            } else if (
              this.peerConnection.connectionState === "disconnected" ||
              this.peerConnection.connectionState === "failed"
            ) {
              this.updateStatus("K·∫øt n·ªëi b·ªã ng·∫Øt");
              this.resetConnection();
            }
          };
        }

        async handleSignalingMessage(message) {
          console.log("Received signaling message:", message);

          switch (message.type) {
            case "joined":
              this.updateStatus(`ƒê√£ tham gia room ${message.roomId}`);
              break;

            case "peer-joined":
              this.updateStatus(`Peer ${message.peerId} ƒë√£ tham gia`);
              break;

            case "ready":
              this.updateStatus("C·∫£ 2 peers ƒë√£ s·∫µn s√†ng, b·∫Øt ƒë·∫ßu k·∫øt n·ªëi...");
              if (this.isInitiator) {
                await this.createOffer();
              }
              break;

            case "offer":
              await this.handleOffer(message.offer);
              break;

            case "answer":
              await this.handleAnswer(message.answer);
              break;

            case "ice-candidate":
              await this.handleIceCandidate(message.candidate);
              break;

            case "peer-left":
              this.updateStatus(`Peer ${message.peerId} ƒë√£ r·ªùi kh·ªèi cu·ªôc g·ªçi`);
              break;

            case "error":
              this.updateStatus(`L·ªói: ${message.message}`);
              break;
          }
        }

        async createOffer() {
          try {
            const offer = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(offer);
            this.signaling.sendOffer(offer);
            this.updateStatus("ƒê√£ g·ª≠i offer");
          } catch (error) {
            console.error("Error creating offer:", error);
            this.updateStatus("L·ªói khi t·∫°o offer");
          }
        }

        async handleOffer(offer) {
          try {
            await this.peerConnection.setRemoteDescription(offer);
            const answer = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(answer);
            this.signaling.sendAnswer(answer);
            this.updateStatus("ƒê√£ g·ª≠i answer");
          } catch (error) {
            console.error("Error handling offer:", error);
            this.updateStatus("L·ªói khi x·ª≠ l√Ω offer");
          }
        }

        async handleAnswer(answer) {
          try {
            await this.peerConnection.setRemoteDescription(answer);
            this.updateStatus("ƒê√£ nh·∫≠n answer");
          } catch (error) {
            console.error("Error handling answer:", error);
            this.updateStatus("L·ªói khi x·ª≠ l√Ω answer");
          }
        }

        async handleIceCandidate(candidate) {
          try {
            await this.peerConnection.addIceCandidate(candidate);
            console.log("Added ICE candidate");
          } catch (error) {
            console.error("Error adding ICE candidate:", error);
          }
        }

        hangup() {
          if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
          }

          if (this.remoteStream) {
            this.remoteStream.getTracks().forEach((track) => track.stop());
            this.remoteStream = null;
          }

          if (this.signaling) {
            this.signaling.disconnect();
          }

          this.remoteVideo.srcObject = null;
          this.isConnected = false;
          this.isInitiator = false;
          this.roomId = null;
          this.peerId = null;

          this.updateStatus("Cu·ªôc g·ªçi ƒë√£ k·∫øt th√∫c");
          this.hideConnectionInfo();
          this.resetButtons();
        }

        toggleMute() {
          if (this.localStream) {
            const audioTrack = this.localStream.getAudioTracks()[0];
            if (audioTrack) {
              audioTrack.enabled = !audioTrack.enabled;
              this.muteBtn.textContent = audioTrack.enabled
                ? "üîá T·∫Øt ti·∫øng"
                : "üîä B·∫≠t ti·∫øng";
            }
          }
        }

        toggleVideo() {
          if (this.localStream) {
            const videoTrack = this.localStream.getVideoTracks()[0];
            if (videoTrack) {
              videoTrack.enabled = !videoTrack.enabled;
              this.videoBtn.textContent = videoTrack.enabled
                ? "üìπ T·∫Øt video"
                : "üìπ B·∫≠t video";
            }
          }
        }

        resetConnection() {
          this.hangup();
        }

        resetButtons() {
          this.startBtn.disabled = false;
          this.callBtn.disabled = true;
          this.hangupBtn.disabled = true;
          this.muteBtn.disabled = true;
          this.videoBtn.disabled = true;

          this.muteBtn.textContent = "üîá T·∫Øt ti·∫øng";
          this.videoBtn.textContent = "üìπ T·∫Øt video";
        }

        updateStatus(message) {
          this.status.textContent = message;
          console.log("Status:", message);
        }

        generateRoomId() {
          return Math.random().toString(36).substring(2, 15);
        }

        generatePeerId() {
          return Math.random().toString(36).substring(2, 15);
        }

        showConnectionInfo() {
          this.connectionDetails.innerHTML = `
            <strong>Room ID:</strong> ${this.roomId}<br>
            <strong>Peer ID:</strong> ${this.peerId}<br>
            <strong>Signaling Server:</strong> ${this.signalingUrl.value}<br>
            <strong>Tr·∫°ng th√°i:</strong> ${
              this.isInitiator ? "Ng∆∞·ªùi t·∫°o cu·ªôc g·ªçi" : "Ng∆∞·ªùi tham gia"
            }
          `;
          this.connectionInfo.style.display = "block";
        }

        hideConnectionInfo() {
          this.connectionInfo.style.display = "none";
        }
      }

      class WebRTCSignaling {
        constructor(serverUrl) {
          this.serverUrl = serverUrl;
          this.ws = null;
          this.roomId = null;
          this.peerId = null;
          this.onMessage = null;
        }

        async connect(roomId, peerId) {
          return new Promise((resolve, reject) => {
            try {
              const wsUrl = this.serverUrl.replace(/^https?/, "wss");
              this.ws = new WebSocket(`${wsUrl}/ws`);
              this.roomId = roomId;
              this.peerId = peerId;

              this.ws.onopen = () => {
                console.log("WebSocket connected");
                this.send({
                  type: "join",
                  roomId: roomId,
                  peerId: peerId,
                });
                resolve();
              };

              this.ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                if (this.onMessage) {
                  this.onMessage(message);
                }
              };

              this.ws.onclose = () => {
                console.log("WebSocket disconnected");
              };

              this.ws.onerror = (error) => {
                console.error("WebSocket error:", error);
                reject(error);
              };
            } catch (error) {
              reject(error);
            }
          });
        }

        send(message) {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(message));
          }
        }

        sendOffer(offer) {
          this.send({
            type: "offer",
            roomId: this.roomId,
            offer: offer,
          });
        }

        sendAnswer(answer) {
          this.send({
            type: "answer",
            roomId: this.roomId,
            answer: answer,
          });
        }

        sendIceCandidate(candidate) {
          this.send({
            type: "ice-candidate",
            roomId: this.roomId,
            candidate: candidate,
          });
        }

        disconnect() {
          if (this.ws) {
            this.send({
              type: "leave",
              roomId: this.roomId,
            });
            this.ws.close();
            this.ws = null;
          }
        }
      }

      // Initialize the app when page loads
      document.addEventListener("DOMContentLoaded", () => {
        const app = new RealVideoCallApp();

        // Set up signaling message handler
        app.signaling = new WebRTCSignaling("");
        app.signaling.onMessage = (message) =>
          app.handleSignalingMessage(message);
      });
    </script>
  </body>
</html>
